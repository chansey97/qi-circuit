#lang racket
(require qi)
(require qi/probe)
(require "../qi-circuit-lib/circuit.rkt")
(require "../qi-circuit-lib/basic-streams.rkt")
(require rackunit)

;; SICP 3.5.3 Exercise 3.78

;; <<figure-3.35>> Signal-flow diagram for the solution to a second-order linear differential equation.
;;  
;;                 dy_0                y_0
;;                  |                   |
;;                  V                   V
;;     ddy     +----------+    dy  +----------+    y
;;  +--------->| integral +-----*--+ integral +--*--->
;;  |          +----------+     |  +----------+  |
;;  |                           |                |
;;  |            +----------+   |                |
;;  |     __/|<--+ scale: a |<--+                |
;;  |   _/   |   +----------+                    |
;;  +--<_add |                                   |
;;       \__ |   +----------+                    |
;;          \|<--+ scale: b |<-------------------+
;;               +----------+

;; Consider the problem of designing a signal-processing system to study the homogeneous second-order
;; linear differential equation
;;
;;  d^2 y        d y
;;  -----  -  a -----  -  by  =  0
;;  d t^2        d t
;;
;; The output stream, modeling y, is generated by a network that contains a loop.  This is because the
;; value of d^2y/dt^2 depends upon the values of y and dy/dt and both of these are determined by integrating
;; d^2y/dt^2.  The diagram we would like to encode is shown in [[figure-3.35][Figure 3.35]].

;; Write a procedure ~solve-2nd~ that takes as arguments the constants a, b, and dt and the
;; initial values y_0 and dy_0 for y and dy/dt and generates the stream of successive values of y.


;; Solving y'' - a y' - by = 0, the initial condition y(0) = y0 and y'(0) = dy0

(define (solve-2nd a b y0 dy0 dt)
  (~>> ()
       (c-loop-gen (~>> (c-reg dy0)
                        (-< (~>> (c-mul dt)
                                 (c-loop (~>> (== _ (c-reg y0))
                                              (c-add +)
                                              (-< _ _)))
                                 (c-reg y0)
                                 (c-mul b))
                            (c-mul a))
                        (c-add +)
                        (c-mul dt)
                        (c-loop (~>> (== _ (c-reg dy0))
                                     (c-add +)
                                     (-< _ _)))
                        (-< _ _)
                        ))
       (c-reg dy0)
       (c-mul dt)
       (c-loop (~>> (== _ (c-reg y0))
                    (c-add +)
                    (-< _ _)))
       (c-reg y0)
       ))


;; For example, let a=-2, b=3, y(0) = 1, y'(0) = 2,
;; i.e. solve y'' + 2y' - 3y = 0 with y(0) = 1, y'(0) = 2
;; Solved: y(t) = (5 e^t)/4 - 1/4 e^(-3 t), so y(1) = 3.3854
;; See https://www.wolframalpha.com/input?i2d=true&i=y%27%27+%2B+2y%27+-+3y+%3D+0%5C%2844%29++y%5C%2840%290%5C%2841%29%3D1%5C%2844%29+y%27%5C%2840%290%5C%2841%29%3D2

(define (solve-y-2nd t)
  (let* ((precision 10000.0)
         (dt (/ 1 precision))
         (a -2)
         (b 3)
         (y0 1)
         (dy0 2))
    (stream-ref (solve-2nd a b y0 2 dt) (inexact->exact (round (* t precision)))))
  )

(check-equal? (solve-y-2nd 1) 3.385241242344665)
